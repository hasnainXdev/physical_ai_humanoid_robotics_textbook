"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[4674],{998:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module1-ros2/05-urdf-modeling","title":"URDF Modeling for Humanoid Robots","description":"1. Introduction to URDF","source":"@site/docs/module1-ros2/05-urdf-modeling.mdx","sourceDirName":"module1-ros2","slug":"/module1-ros2/05-urdf-modeling","permalink":"/docs/module1-ros2/05-urdf-modeling","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module1-ros2/05-urdf-modeling.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"05-urdf-modeling","title":"URDF Modeling for Humanoid Robots","sidebar_label":"URDF Modeling"},"sidebar":"tutorialSidebar","previous":{"title":"Launch Files","permalink":"/docs/module1-ros2/04-launch-files"},"next":{"title":"AI Integration","permalink":"/docs/module1-ros2/06-ai-integration"}}');var o=i(4848),t=i(8453),a=(i(3457),i(2352));const l={id:"05-urdf-modeling",title:"URDF Modeling for Humanoid Robots",sidebar_label:"URDF Modeling"},s=void 0,d={},c=[{value:"1. Introduction to URDF",id:"1-introduction-to-urdf",level:2},{value:"Key URDF Elements",id:"key-urdf-elements",level:3},{value:"2. Creating a Simple Humanoid URDF",id:"2-creating-a-simple-humanoid-urdf",level:2},{value:"The Torso Link",id:"the-torso-link",level:3},{value:"The Head Link and Neck Joint",id:"the-head-link-and-neck-joint",level:3},{value:"Visualizing the URDF",id:"visualizing-the-urdf",level:3},{value:"3. Using Xacro for Cleaner URDFs",id:"3-using-xacro-for-cleaner-urdfs",level:2},{value:"Example: A Reusable Arm Macro",id:"example-a-reusable-arm-macro",level:3},{value:"4. Modeling a Full Humanoid",id:"4-modeling-a-full-humanoid",level:2},{value:"Tips for Humanoid URDFs",id:"tips-for-humanoid-urdfs",level:3},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"1-introduction-to-urdf",children:"1. Introduction to URDF"}),"\n",(0,o.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is an XML format used in ROS to describe all elements of a robot. This includes the robot's links, joints, sensors, and their physical properties. A well-defined URDF is crucial for simulation, visualization, and control of your robot."}),"\n",(0,o.jsx)(n.p,{children:"For a humanoid robot, the URDF will be a complex tree of links and joints, representing everything from the torso and limbs to individual finger segments."}),"\n",(0,o.jsx)(n.h3,{id:"key-urdf-elements",children:"Key URDF Elements"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<robot>"})}),": The root element of the URDF file."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<link>"})}),": Describes a rigid body part of the robot. It has properties like ",(0,o.jsx)(n.code,{children:"inertial"}),", ",(0,o.jsx)(n.code,{children:"visual"}),", and ",(0,o.jsx)(n.code,{children:"collision"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<joint>"})}),": Connects two links together. It defines the relationship between the links, including the joint type (",(0,o.jsx)(n.code,{children:"revolute"}),", ",(0,o.jsx)(n.code,{children:"continuous"}),", ",(0,o.jsx)(n.code,{children:"prismatic"}),", ",(0,o.jsx)(n.code,{children:"fixed"}),"), axis of rotation, and limits."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<visual>"})}),": Defines the visual representation of a link (e.g., a 3D mesh)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<collision>"})}),": Defines the collision geometry of a link, used for physics simulation."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"<inertial>"})}),": Defines the inertial properties of a link (mass, moment of inertia)."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"2-creating-a-simple-humanoid-urdf",children:"2. Creating a Simple Humanoid URDF"}),"\n",(0,o.jsx)(n.p,{children:"Let's start by creating a very simple URDF for a humanoid robot, consisting of a torso and a head."}),"\n",(0,o.jsx)(n.h3,{id:"the-torso-link",children:"The Torso Link"}),"\n",(0,o.jsx)(n.p,{children:"The torso will be the root link of our robot."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<link name="torso">\n  <visual>\n    <geometry>\n      <box size="0.4 0.6 0.2" />\n    </geometry>\n    <material name="blue">\n      <color rgba="0.0 0.0 1.0 1.0" />\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.4 0.6 0.2" />\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="10" />\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0" />\n  </inertial>\n</link>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"the-head-link-and-neck-joint",children:"The Head Link and Neck Joint"}),"\n",(0,o.jsx)(n.p,{children:"Now, let's add a head link and a neck joint to connect it to the torso."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<link name="head">\n  <visual>\n    <geometry>\n      <sphere radius="0.15" />\n    </geometry>\n    <material name="white">\n      <color rgba="1.0 1.0 1.0 1.0" />\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <sphere radius="0.15" />\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="2" />\n    <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1" />\n  </inertial>\n</link>\n\n<joint name="neck" type="revolute">\n  <parent link="torso" />\n  <child link="head" />\n  <origin xyz="0.0 0.0 0.15" rpy="0.0 0.0 0.0" />\n  <axis xyz="0 0 1" />\n  <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0" />\n</joint>\n'})}),"\n",(0,o.jsx)(n.p,{children:"This defines a revolute joint (a rotating joint) that allows the head to turn."}),"\n",(0,o.jsx)(n.h3,{id:"visualizing-the-urdf",children:"Visualizing the URDF"}),"\n",(0,o.jsx)(n.p,{children:"You can visualize your URDF using RViz, a 3D visualization tool for ROS. You'll need a launch file to display the robot model."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch_ros.parameter_descriptions import ParameterValue\nfrom launch.substitutions import Command\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    urdf_path = os.path.join(\n        get_package_share_directory('my_robot_description'),\n        'urdf',\n        'my_humanoid.urdf'\n    )\n\n    robot_description = ParameterValue(\n        Command(['xacro ', urdf_path]),\n        value_type=str\n    )\n\n    return LaunchDescription([\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            parameters=[{'robot_description': robot_description}]\n        ),\n        Node(\n            package='rviz2',\n            executable='rviz2',\n            name='rviz2',\n            output='screen',\n        ),\n    ])\n"})}),"\n",(0,o.jsx)(n.h2,{id:"3-using-xacro-for-cleaner-urdfs",children:"3. Using Xacro for Cleaner URDFs"}),"\n",(0,o.jsx)(n.p,{children:"As your humanoid robot becomes more complex, the URDF file can become very large and difficult to manage. Xacro (XML Macros) is a macro language for URDF that allows you to create more modular and readable robot descriptions."}),"\n",(0,o.jsx)(n.p,{children:"With Xacro, you can:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Define constants and properties."}),"\n",(0,o.jsx)(n.li,{children:"Create macros for reusable components (e.g., an arm, a leg)."}),"\n",(0,o.jsx)(n.li,{children:"Include other Xacro files."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-a-reusable-arm-macro",children:"Example: A Reusable Arm Macro"}),"\n",(0,o.jsx)(n.p,{children:"Here's an example of a Xacro macro for a simple robot arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<robot xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  <xacro:macro name="robot_arm" params="prefix parent *origin">\n\n    <link name="${prefix}_upper_arm">\n      ...\n    </link>\n\n    <joint name="${prefix}_shoulder" type="revolute">\n      <parent link="${parent}" />\n      <child link="${prefix}_upper_arm" />\n      <xacro:insert_block name="origin" />\n    </joint>\n\n    ...\n\n  </xacro:macro>\n\n</robot>\n'})}),"\n",(0,o.jsx)(n.p,{children:"You can then instantiate this macro for the left and right arms:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<xacro:robot_arm prefix="left" parent="torso">\n  <origin xyz="0.0 0.3 0.0" rpy="0.0 0.0 0.0" />\n</xacro:robot_arm>\n\n<xacro:robot_arm prefix="right" parent="torso">\n  <origin xyz="0.0 -0.3 0.0" rpy="0.0 0.0 0.0" />\n</xacro:robot_arm>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"4-modeling-a-full-humanoid",children:"4. Modeling a Full Humanoid"}),"\n",(0,o.jsx)(n.p,{children:"A full humanoid URDF will have many links and joints, organized in a tree structure."}),"\n",(0,o.jsx)(a.A,{chart:"\ngraph TD\n  base_link --\x3e torso;\n  torso --\x3e head;\n  torso --\x3e left_shoulder;\n  torso --\x3e right_shoulder;\n  left_shoulder --\x3e left_upper_arm;\n  right_shoulder --\x3e right_upper_arm;\n  left_upper_arm --\x3e left_lower_arm;\n  right_upper_arm --\x3e right_lower_arm;\n  torso --\x3e left_hip;\n  torso --\x3e right_hip;\n  left_hip --\x3e left_upper_leg;\n  right_hip --\x3e right_upper_leg;\n  left_upper_leg --\x3e left_lower_leg;\n  right_upper_leg --\x3e right_lower_leg;\n"}),"\n",(0,o.jsx)(n.h3,{id:"tips-for-humanoid-urdfs",children:"Tips for Humanoid URDFs"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Start with a simple model and add complexity gradually."})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Use Xacro to keep your URDF organized."})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Pay close attention to joint limits and axes of rotation."})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Use realistic inertial properties for better simulation."})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Use high-quality 3D meshes for visualization."})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"URDF is the foundation for working with robot models in ROS 2. For a complex robot like a humanoid, a well-structured and accurate URDF is essential for everything from simulation to real-world control. By using Xacro and following a modular approach, you can create a detailed and maintainable description of your humanoid robot."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},2352:(e,n,i)=>{i.d(n,{A:()=>g});var r=i(6540),o=i(7489),t=i(2181),a=i(6342),l=i(5293);let s=null;async function d(){return s||(s=async function(){return(await i.e(2279).then(i.bind(i,2279))).default}()),s}const c="docusaurus-mermaid-container";function u(){const{colorMode:e}=(0,l.G)(),n=(0,a.p)().mermaid,i=n.theme[e],{options:o}=n;return(0,r.useMemo)(()=>({startOnLoad:!1,...o,theme:i}),[i,o])}function h({text:e,config:n}){const[i,o]=(0,r.useState)(null),t=(0,r.useState)(`mermaid-svg-${Math.round(1e7*Math.random())}`)[0],a=u(),l=n??a;return(0,r.useEffect)(()=>{(async function({id:e,text:n,config:i}){const r=await d();r.initialize(i);try{return await r.render(e,n)}catch(o){throw document.querySelector(`#d${e}`)?.remove(),o}})({id:t,text:e,config:l}).then(o).catch(e=>{o(()=>{throw e})})},[t,e,l]),i}const m={container:"container_lyt7"};var p=i(4848);function x({renderResult:e}){const n=(0,r.useRef)(null);return(0,r.useEffect)(()=>{const i=n.current;e.bindFunctions?.(i)},[e]),(0,p.jsx)("div",{ref:n,className:`${c} ${m.container}`,dangerouslySetInnerHTML:{__html:e.svg}})}function f({value:e}){const n=h({text:e});return null===n?null:(0,p.jsx)(x,{renderResult:n})}function g(e){return(0,p.jsx)(o.A,{fallback:e=>(0,p.jsx)(t.MN,{...e}),children:(0,p.jsx)(f,{...e})})}}}]);