"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[9961],{2352:(e,n,t)=>{t.d(n,{A:()=>f});var i=t(6540),s=t(7489),o=t(2181),a=t(6342),r=t(5293);let l=null;async function c(){return l||(l=async function(){return(await t.e(2279).then(t.bind(t,2279))).default}()),l}const d="docusaurus-mermaid-container";function h(){const{colorMode:e}=(0,r.G)(),n=(0,a.p)().mermaid,t=n.theme[e],{options:s}=n;return(0,i.useMemo)(()=>({startOnLoad:!1,...s,theme:t}),[t,s])}function u({text:e,config:n}){const[t,s]=(0,i.useState)(null),o=(0,i.useState)(`mermaid-svg-${Math.round(1e7*Math.random())}`)[0],a=h(),r=n??a;return(0,i.useEffect)(()=>{(async function({id:e,text:n,config:t}){const i=await c();i.initialize(t);try{return await i.render(e,n)}catch(s){throw document.querySelector(`#d${e}`)?.remove(),s}})({id:o,text:e,config:r}).then(s).catch(e=>{s(()=>{throw e})})},[o,e,r]),t}const p={container:"container_lyt7"};var m=t(4848);function g({renderResult:e}){const n=(0,i.useRef)(null);return(0,i.useEffect)(()=>{const t=n.current;e.bindFunctions?.(t)},[e]),(0,m.jsx)("div",{ref:n,className:`${d} ${p.container}`,dangerouslySetInnerHTML:{__html:e.svg}})}function x({value:e}){const n=u({text:e});return null===n?null:(0,m.jsx)(g,{renderResult:n})}function f(e){return(0,m.jsx)(s.A,{fallback:e=>(0,m.jsx)(o.MN,{...e}),children:(0,m.jsx)(x,{...e})})}},7934:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module2-digital-twins/06-ai-pipelines","title":"Connecting Sensor Outputs to AI Pipelines","description":"1. From Raw Data to Actionable Insights","source":"@site/docs/module2-digital-twins/06-ai-pipelines.mdx","sourceDirName":"module2-digital-twins","slug":"/module2-digital-twins/06-ai-pipelines","permalink":"/docs/module2-digital-twins/06-ai-pipelines","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module2-digital-twins/06-ai-pipelines.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"06-ai-pipelines","title":"Connecting Sensor Outputs to AI Pipelines","sidebar_label":"AI Pipelines"},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation","permalink":"/docs/module2-digital-twins/05-sensor-simulation"},"next":{"title":"Introduction","permalink":"/docs/module3-nvidia-isaac-sim/01-introduction"}}');var s=t(4848),o=t(8453),a=t(2352);const r={id:"06-ai-pipelines",title:"Connecting Sensor Outputs to AI Pipelines",sidebar_label:"AI Pipelines"},l=void 0,c={},d=[{value:"1. From Raw Data to Actionable Insights",id:"1-from-raw-data-to-actionable-insights",level:2},{value:"A Typical AI Pipeline",id:"a-typical-ai-pipeline",level:3},{value:"2. Example: An Object Detection Pipeline",id:"2-example-an-object-detection-pipeline",level:2},{value:"Step 1: The Simulator (Data Source)",id:"step-1-the-simulator-data-source",level:3},{value:"Step 2: The AI Node (Processing)",id:"step-2-the-ai-node-processing",level:3},{value:"Step 3: The Output (Actionable Information)",id:"step-3-the-output-actionable-information",level:3},{value:"Why This Decoupling is Powerful",id:"why-this-decoupling-is-powerful",level:3},{value:"3. Integrating State Estimation",id:"3-integrating-state-estimation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"1-from-raw-data-to-actionable-insights",children:"1. From Raw Data to Actionable Insights"}),"\n",(0,s.jsxs)(n.p,{children:["Having a digital twin that produces realistic sensor data is the first step. The next, and more critical, step is to process this stream of data and turn it into information that an AI agent can use to make decisions. This process is often called an ",(0,s.jsx)(n.strong,{children:"AI pipeline"})," or a ",(0,s.jsx)(n.strong,{children:"perception pipeline"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The pipeline is a series of nodes, each responsible for a specific processing task. The output of one node becomes the input of the next, creating a flow of information from raw sensor readings to high-level understanding."}),"\n",(0,s.jsx)(n.h3,{id:"a-typical-ai-pipeline",children:"A Typical AI Pipeline"}),"\n",(0,s.jsx)(a.A,{chart:"\ngraph TD\n  subgraph Digital Twin (Gazebo/Unity)\n      A[Simulated Camera] --\x3e|sensor_msgs/Image| B((/camera/image_raw));\n      C[Simulated LiDAR] --\x3e|sensor_msgs/PointCloud2| D((/lidar/points));\n      E[Simulated IMU] --\x3e|sensor_msgs/Imu| F((/imu/data));\n  end\n\n  subgraph ROS 2 Perception Pipeline\n      B --\x3e G[Node: Object Detector];\n      G --\x3e|vision_msgs/Detection3DArray| H((/objects/detected));\n      D --\x3e I[Node: Obstacle Detector];\n      I --\x3e|custom_msgs/ObstacleArray| J((/obstacles));\n      F --\x3e K[Node: State Estimator];\n      K --\x3e|nav_msgs/Odometry| L((/odometry/filtered));\n  end\n\n  subgraph AI Agent / Planner\n      H --\x3e M{Decision Making};\n      J --\x3e M;\n      L --\x3e M;\n      M --\x3e|geometry_msgs/Twist| N((/cmd_vel));\n  end\n\n  style B fill:#87CEEB\n  style D fill:#87CEEB\n  style F fill:#87CEEB\n  style H fill:#90EE90\n  style J fill:#90EE90\n  style L fill:#90EE90\n  style N fill:#FFA07A\n"}),"\n",(0,s.jsx)(n.p,{children:"In this example, raw data from simulated sensors (camera, LiDAR, IMU) is published to ROS 2 topics. A set of perception nodes subscribes to these topics, processes the data, and publishes higher-level information (detected objects, obstacles, robot pose). Finally, the AI agent uses this processed information to make a decision and send a command to the robot's controllers."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"2-example-an-object-detection-pipeline",children:"2. Example: An Object Detection Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"Let's walk through a concrete example: using a simulated camera to detect objects."}),"\n",(0,s.jsx)(n.h3,{id:"step-1-the-simulator-data-source",children:"Step 1: The Simulator (Data Source)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simulator"}),": Unity or Gazebo."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor"}),": A simulated camera attached to the humanoid's head."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action"}),": The simulator's ROS 2 plugin renders the scene from the camera's viewpoint and publishes the resulting image to the ",(0,s.jsx)(n.code,{children:"/camera/image_raw"})," topic as a ",(0,s.jsx)(n.code,{children:"sensor_msgs/Image"})," message. This happens at a regular rate, for example, 30 times per second (30 Hz)."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-2-the-ai-node-processing",children:"Step 2: The AI Node (Processing)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Node"}),": An object detection node, likely written in Python using a deep learning framework like TensorFlow or PyTorch."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subscription"}),": The node subscribes to the ",(0,s.jsx)(n.code,{children:"/camera/image_raw"})," topic."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Core Logic"}),":","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Callback"}),": Whenever a new image message is received, the node's callback function is triggered."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conversion"}),": The ROS 2 ",(0,s.jsx)(n.code,{children:"Image"})," message is converted into a format that the deep learning model can understand (e.g., a NumPy array or a PyTorch tensor). Libraries like ",(0,s.jsx)(n.code,{children:"cv_bridge"})," are commonly used for this."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inference"}),": The image is passed through a pre-trained object detection model (e.g., YOLO, SSD, Faster R-CNN)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Result"}),': The model outputs a list of detected objects, each with a class label (e.g., "cup," "book"), a confidence score, and a bounding box.']}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-3-the-output-actionable-information",children:"Step 3: The Output (Actionable Information)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publication"}),": The object detection node publishes the results to a new topic, for example, ",(0,s.jsx)(n.code,{children:"/objects/detected"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Type"}),": The message type should be structured to hold the detection information. ROS 2 has a standard message type for this: ",(0,s.jsx)(n.code,{children:"vision_msgs/Detection3DArray"}),", which can store the object's identity, position, and size."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Downstream Consumer"}),': The AI planner or a specific task-oriented node (e.g., a "grasping" node) can now subscribe to ',(0,s.jsx)(n.code,{children:"/objects/detected"}),'. It no longer needs to worry about the raw pixels; it can work directly with the high-level information: "There is a cup at position (x, y, z)."']}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"why-this-decoupling-is-powerful",children:"Why This Decoupling is Powerful"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),": The object detection node is a self-contained component. You can swap out the AI model (e.g., upgrade from YOLOv5 to YOLOv8) without changing any other part of the system."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusability"}),": You can use the same object detection node with a real camera by simply remapping the input topic. The node doesn't care if the image comes from a simulator or a physical device."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficiency"}),": Raw sensor data, especially from cameras and LiDAR, can have a very high bandwidth. By processing it close to the source and publishing only the high-level results, you reduce the overall data load on the ROS 2 network."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"3-integrating-state-estimation",children:"3. Integrating State Estimation"}),"\n",(0,s.jsxs)(n.p,{children:["While detecting external objects is crucial, the robot also needs to know its own state\u2014its position, orientation, and velocity. This is the job of a ",(0,s.jsx)(n.strong,{children:"state estimator"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inputs"}),": The state estimator typically fuses data from multiple sensors, most commonly an ",(0,s.jsx)(n.strong,{children:"IMU"})," (for orientation and acceleration) and ",(0,s.jsx)(n.strong,{children:"wheel odometry"})," (for movement tracking, if the robot has wheels) or ",(0,s.jsx)(n.strong,{children:"leg kinematics"})," (for humanoids)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Algorithm"}),": It uses a filtering algorithm, like an ",(0,s.jsx)(n.strong,{children:"Extended Kalman Filter (EKF)"})," or an ",(0,s.jsx)(n.strong,{children:"Unscented Kalman Filter (UKF)"}),", to combine these noisy and incomplete sensor readings into a single, more accurate estimate of the robot's state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output"}),": The estimator publishes the robot's state to a topic like ",(0,s.jsx)(n.code,{children:"/odometry/filtered"})," using the ",(0,s.jsx)(n.code,{children:"nav_msgs/Odometry"})," message type."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Importance"}),': Nearly every other AI task, from navigation to manipulation, depends on having an accurate estimate of the robot\'s own pose. Your AI needs to know "Where am I?" before it can decide "What should I do?".']}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Connecting sensor outputs to AI pipelines is the essence of building an intelligent robot. By using the ROS 2 publisher/subscriber model, you can create modular, decoupled pipelines that transform raw, high-bandwidth sensor data from your digital twin into the high-level, actionable insights needed by your AI agents. This architecture is fundamental to creating a robust and scalable robotics software system."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);